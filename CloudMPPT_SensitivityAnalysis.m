%% CloudMPPT_SensitivityAnalysis.m
% Sensitivity analysis of fault detection thresholds
% Uses 'results' struct generated by CloudMPPT_FullAnalytics.m

clearvars -except results; clc;

if ~exist('results','var')
    error('results not found. First run CloudMPPT_FullAnalytics.m');
end

% --- تنظیمات ---
t_fault = 1.0;    % همان زمانی که در TestScenario خطا را فعال کردیم

% آستانه‌هایی که می‌خواهیم sweep کنیم
eff_thr_vec = 0.70:0.05:0.85;   % Eff_fault
qos_thr_vec = 0.40:0.05:0.60;   % QoS_fault

Ne = numel(eff_thr_vec);
Nq = numel(qos_thr_vec);

DetectionRate = zeros(Ne, Nq);   % نسبت تشخیص صحیح
FalseAlarmRate = zeros(Ne, Nq);  % نسبت آلارم کاذب در تست 0

% شناسه تست‌ها (همان که در FullAnalytics استفاده شد)
% Test 0 = baseline, 1 = MPPT fault, 2 = COMM fault, 3 = GLOBAL fault
trueClass_for_TestID = [0 1 2 3];

%% تابع کوچک برای طبقه‌بندی بر اساس آستانه‌ها
classifySample = @(eff, qos, eff_fault, qos_fault) ...
    localClassify(eff, qos, eff_fault, qos_fault);

%% حلقه تحلیل حساسیت
for ie = 1:Ne
    eff_fault = eff_thr_vec(ie);
    
    % eff_warn را کمی بالاتر از eff_fault می‌گیریم
    eff_warn = min(eff_fault + 0.1, 0.99);
    
    for jq = 1:Nq
        qos_fault = qos_thr_vec(jq);
        qos_warn  = min(qos_fault + 0.2, 0.99);
        
        % --- ۱) نرخ تشخیص صحیح روی تست‌های 1،2،3 ---
        correct = 0;
        total   = 0;
        
        for kTest = 2:4   % indices 2,3,4 -> TestID 1,2,3
            TID   = results(kTest).TestID;
            trueC = trueClass_for_TestID(TID+1);   % 1,2,3
            
            t   = results(kTest).Time;
            eff = results(kTest).Eff;
            qos = results(kTest).QoS;
            
            idx = t >= t_fault;   % فقط بعد از فعال شدن خطا
            t   = t(idx);
            eff = eff(idx);
            qos = qos(idx);
            
            for n = 1:numel(t)
                c_hat = classifySample(eff(n), qos(n), eff_fault, qos_fault);
                
                % منطق مشابه FaultDetection:
                % استفاده از eff_warn و qos_warn
                if (eff(n) < eff_fault && qos(n) >= qos_warn)
                    c_hat = 1;  % MPPT fault
                elseif (qos(n) < qos_fault && eff(n) >= eff_warn)
                    c_hat = 2;  % COMM fault
                elseif (eff(n) < eff_fault && qos(n) < qos_fault)
                    c_hat = 3;  % GLOBAL fault
                else
                    c_hat = 0;  % No fault
                end
                
                if c_hat == trueC
                    correct = correct + 1;
                end
                total = total + 1;
            end
        end
        
        DetectionRate(ie, jq) = correct / max(total,1);
        
        % --- ۲) نرخ آلارم کاذب روی تست 0 (baseline) ---
        t0   = results(1).Time;
        eff0 = results(1).Eff;
        qos0 = results(1).QoS;
        
        idx0 = t0 >= t_fault;
        t0   = t0(idx0);
        eff0 = eff0(idx0);
        qos0 = qos0(idx0);
        
        falseAlarm = 0;
        total0     = numel(t0);
        
        for n = 1:total0
            % همان منطق طبقه‌بندی
            if (eff0(n) < eff_fault && qos0(n) >= qos_warn)
                c0 = 1;
            elseif (qos0(n) < qos_fault && eff0(n) >= eff_warn)
                c0 = 2;
            elseif (eff0(n) < eff_fault && qos0(n) < qos_fault)
                c0 = 3;
            else
                c0 = 0;
            end
            
            if c0 ~= 0
                falseAlarm = falseAlarm + 1;
            end
        end
        
        FalseAlarmRate(ie, jq) = falseAlarm / max(total0,1);
    end
end

%% ۳) نمایش نتایج به صورت نقشه حرارتی

figure('Name','Sensitivity - Detection Rate','NumberTitle','off');
imagesc(qos_thr_vec, eff_thr_vec, DetectionRate);
set(gca,'YDir','normal');
xlabel('QoS\_fault threshold'); ylabel('Eff\_fault threshold');
title('Overall Correct Detection Rate');
colorbar;

figure('Name','Sensitivity - False Alarm Rate','NumberTitle','off');
imagesc(qos_thr_vec, eff_thr_vec, FalseAlarmRate);
set(gca,'YDir','normal');
xlabel('QoS\_fault threshold'); ylabel('Eff\_fault threshold');
title('False Alarm Rate on Baseline (Test 0)');
colorbar;

%% ۴) خروجی عددی برای چند نقطهٔ مهم (فعلی و همسایه‌ها)

% آستانه فعلی در مدل (طبق کدی که داشتیم):
eff_nom = 0.80;
qos_nom = 0.50;

% نزدیک‌ترین نقطه در شبکه:
[~,ie_nom] = min(abs(eff_thr_vec - eff_nom));
[~,jq_nom] = min(abs(qos_thr_vec - qos_nom));

fprintf('\n=== Sensitivity around nominal thresholds ===\n');
for ie = max(1,ie_nom-1):min(Ne,ie_nom+1)
    for jq = max(1,jq_nom-1):min(Nq,jq_nom+1)
        fprintf('Eff_thr=%.2f, QoS_thr=%.2f -> Detect=%.2f, FalseAlarm=%.2f\n',...
            eff_thr_vec(ie), qos_thr_vec(jq), ...
            DetectionRate(ie,jq), FalseAlarmRate(ie,jq));
    end
end


%% --- Local function (برای سازگاری با codegen می‌توان جدا نوشت) ---
function c = localClassify(eff, qos, eff_fault, qos_fault) %#ok<DEFNU>
% این نسخه ساده است؛ در حلقه اصلی منطق کامل‌تر را نوشتیم.
c = 0; %#ok<NASGU>
% فقط برای سازگاری؛ منطق اصلی همان بالا در حلقه استفاده شده است.
end
